" Variables
" reg c = command
" reg s = state

= reg d (for delay)
VV

=BEGIN

VV  -> Flash visual mode on and off

=END

= reg t (for turing)
OSTART0"syEdd@l

=BEGIN
  -> set state to START
OSTART  -> write out the start state
0"syE     -> load the start state in s
dd        -> clean up

  -> run the main loop
@l
=END

= reg l (for loop)
5000@d0"cy$l@j5000@d@rh5000@d@w@m
0"cy$l@j@rh@w@m


=BEGIN
0"cy$     -> load the line into c
l       -> go to the turing instructions
@j        -> jump to command
@r        -> read state machine commands
h       -> go to the tape
@w        -> write to the tape
@m        -> execute the motion
=END



= reg j (for jump to command)
/^s\s\+{\_[^}]*(c)\_[^}]*}/(c)/ : ww

=BEGIN

 -> jump to the state containing your command
 -> or fail if it doesn't exist
/         -> start search
^s\s\+{ -> line starting with [state] {
\_[^}]*   -> no closing braces
(c)     -> the command wrapped in parentheses
\_[^}]*   -> no closing braces
}         -> a closing brace starting a line
        -> enter (to start the search)

 -> now we are know the bracketed group we are in contains
 -> so we are safe to jump to the specific command more
 -> niaively
/(c)  -> jump to command
/ : ww  -> jump to the first subexpression

=END

= reg r (read state machine commands)
"wyewmp/^WRITE-CMDS\s(\_[^)]*w\_[^)]*)/wf:w"wy$G@w"wdd`p"myewmp/^MOTION-CMDS\s(\_[^)]*m\_[^)]*)/mf:w"my$`p"syE

=BEGIN

  -> Load part w (for write)

  -> read the write cmd
"wye               -> load command (temporarily) into reg w
wmp                -> advance to next command, mark place

  -> search for macro related to write-cmd
/^WRITE-CMDS\s(    -> only look in the write cmds
\_[^)]*w\_[^)]*  -> make sure the command occurs before any closing paren
)                -> complete search
/w             -> now find individual command

  -> load cmd into w
f:w"wy$            -> yank that macro (temporarily) into w
G@w                -> go to the bottom, call temp w
"wdd               -> finally load into w

  -> load part m for motion
`p                 -> return to where we left off
"mye               -> load command (temporarily) into reg m
wmp                -> advance to next command, mark place

  -> search for macro related to motion-cmd
/^MOTION-CMDS\s(   -> only look in the motion cmds
\_[^)]*m\_[^)]*  -> make sure the command occurs before any closing paren
)                -> complete search
/m             -> now find individual command

  -> now load the actual motion
f:w"my$

  -> load the state
`p                 -> return to place
"syE               -> load state

=END

WRITE-CMDS (
  SKIP  : o0
  DEL   : odd
  WRITE : `pl"wyi"f"wmpGo0CECh"wp
  INS   : `pl"wyi"f"wmpGooECh"wp
)

MOTION-CMDS (
  UP   : k@l
  DWN  : j@l
  HLD  : 0@l
  STOP : 0
)

STATE {
  (1) : SKIP      DWN STATE
  (2) : WRITE "1" DWN STATE
  (3) : DEL       HLD STATE
  (4) : SKIP      HLD OTHER
}

START {
  ()(0)(1) : SKIP HLD SCAN-UP
}

ADD-1 {
  (0) : WRITE "1" HLD DONE
  (1) : WRITE "0" DWN ADD-1
  ()  : SKIP      UP  INS-1
}

SCAN-UP {
  (0)(1) : SKIP UP  SCAN-UP
  ()     : SKIP DWN ADD-1
}

INS-1 {
  ()(0)(1) : INS "1" HLD DONE
}

OTHER {
  (4) : INS "5" DWN DONE
}

DONE {
  ()(1)(2)(3)(4)(5) : SKIP STOP DONE
}
