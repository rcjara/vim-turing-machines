" Variables
" reg c = command
" reg s = state

= reg d (for delay)
VV

=BEGIN

VV  -> Flash visual mode on and off

=END

= reg t (for turing)
OSTART0"syEdd@l

=BEGIN
  -> set state to START
OSTART  -> write out the start state
0"syE     -> load the start state in s
dd        -> clean up

  -> run the main loop
@l
=END

= reg l (for loop)
0"cy$l@j@rh@w@m


=BEGIN
0"cy$     -> load the line into c
l       -> go to the turing instructions
@j        -> jump to command
@r        -> read state machine commands
h       -> go to the tape
@w        -> write to the tape
@m        -> execute the motion
=END



= reg j (for jump to command)
/^s\s\+{\_[^}]*(c).*\s:\s\+\zs\_[^}]*}

=BEGIN

 -> jump to the state containing your command
 -> or fail if it doesn't exist
/         -> start search
^s\s\+{ -> line starting with [state] {
\_[^}]*   -> no closing braces
(c)     -> the command wrapped in parentheses
.*\s:\s\+ -> the colon surrounded by white space
          -> NOTE that we don't include new lines here
          -> i.e. the colon has to occur on the same line
\zs       -> start the match after the colon (so we jump right to it)
\_[^}]*   -> no closing braces
}         -> a closing brace starting a line
        -> enter (to execute the search)

=END

= reg r (read state machine commands)
"wyewmp/^WRITE-CMDS\s(\_[^)]*w.*\s:\s\+\zs\_[^)]*)"wy$G@w"wdd`p"myewmp/^MOTION-CMDS\s(\_[^)]*m.*\s:\s\+\zs\_[^)]*)"my$`p"syE

=BEGIN

  -> Load part w (for write)

  -> read the write cmd
"wye               -> load command (temporarily) into reg w
wmp                -> advance to next command, mark place

  -> search for macro related to write-cmd
/                  -> start search
^WRITE-CMDS\s(     -> only look in the write cmds
\_[^)]*            -> no closing parens
w                -> the matching command
.*\s:\s\+          -> the colon separating the commands
\zs                -> begin match (so we jump after the colon
\_[^)]*            -> make sure the command occurs before any closing paren
)                -> complete search

  -> load cmd into w
"wy$               -> yank that macro (temporarily) into w
G@w                -> go to the bottom, call temp w
"wdd               -> finally load into w

  -> load part m for motion
`p                 -> return to where we left off
"mye               -> load command (temporarily) into reg m
wmp                -> advance to next command, mark place

  -> search for macro related to motion-cmd
  -> (same comments as write-cmd above)
/
^MOTION-CMDS\s(
\_[^)]*
m
.*\s:\s\+
\zs
\_[^)]*
)

  -> load the actual motion
"my$

  -> load the state
`p                 -> return to place
"syE               -> load state

=END

WRITE-CMDS (
  SKIP  : o0
  DEL   : odd
  WRITE : `pl"wyi"f"wmpGo0CECh"wp
  INS   : `pl"wyi"f"wmpGooECh"wp
)

MOTION-CMDS (
  UP   : k@l
  DWN  : j@l
  HLD  : 0@l
  STOP : 0
)

STATE {
  (1) : SKIP      DWN STATE
  (2) : WRITE "1" DWN STATE
  (3) : DEL       HLD STATE
  (4) : SKIP      HLD OTHER
}

START {
  ()(0)(1) :   SKIP HLD SCAN-UP
}

ADD-1 {
  (0) : WRITE "1" HLD DONE
  (1) : WRITE "0" DWN ADD-1
  ()  : SKIP      UP  INS-1
}

SCAN-UP {
  (0)(1) : SKIP UP  SCAN-UP
  ()     : SKIP DWN ADD-1
}

INS-1 {
  ()(0)(1) : INS "1" HLD DONE
}

OTHER {
  (4) : INS "5" DWN DONE
}

DONE {
  ()(1)(2)(3)(4)(5) : SKIP STOP DONE
}
