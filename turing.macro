" Variables
" reg c = command
" reg s = state

= reg i (for initialize)
GoWRITE-CMDS ( ):%s/^WRITE-CMDS\s(\_[^)]\+)\_.//GoWRITE-CMDS (SKIP  : o0ECDEL   : oddECWRITE : `pl"wyi"f"wmpGo0CVTECECh"wpINS   : `pl"wyi"f"wmpGooVTECECh"wp)GoMOTION-CMDS ( ):%s/^MOTION-CMDS\s(\_[^)]\+)\_.//GoMOTION-CMDS (UP   : k@lDWN  : j@lHLD  : 0@lSTOP : 0)GoGoEC"cpI*EC:s/\([*\\]\)/\\\\\\\1/gCR0xxxxI(EC:s/\([(){]\)/\\\\\1/gCR0xxxI.EC:s/\([.[\]/^$]\)/\\\1/gCR0xx"cd$dd"eddGo/^D2s\s\+{\_[^}]\{-}\(\\\@<!(\*)\|\\\@<!(D2c\(\\\\\)*)\).*\s:\s\+\zs\_[^}]*}CR"jddGo"wyewmp/^WRITE-CMDS\s(\_[^)]*D2w.*\s:\s\+\zs\_[^)]*)CR"wy$G@w"wdd`p"myewmp/^MOTION-CMDS\s(\_[^)]*D2m.*\s:\s\+\zs\_[^)]*)CR"my$`p"syE"rddGo0"cy$EBl@e@j@rEBh@w@m"lddGoOSTARTEC0"syEdd@l"tdd

=BEGIN
  -> WRITE-CMD block
     -> first write out an empty block
GoWRITE-CMDS ( )
     -> delete all write-cmd blocks
:%s/             -> begin match over whole file
^WRITE-CMDS\s(   -> beginning of block
\_[^)]\+         -> any non-closing paren (including new lines)
)\_.             -> closing block and new line
//             -> substitue for nothing
     -> write out the write-cmd group
     -> all of the sub commands will themselves be yanked into reg w
     -> there is double escaping going on whenever you see ^KVT
        -> header
GoWRITE-CMDS (
        -> skip cmd
SKIP  : o0EC        -> write out "0"
        -> del cmd
DEL   : oddEC       -> write out "dd"
        -> write cmd
WRITE : `p                -> header plus jump to mark p
l"wyi"                    -> yank what is in quotes to reg w
f"wmp                     -> go to the next instruction, mark place
Go                        -> bottom of file begin writing
0CVTECEC              -> write out a macro that replaces text with nothing
h"wp                    -> alter the macro so it replaces text with reg w
        -> ins cmd
        -> comments moster same as write cmd above
INS   : `p
l"wyi"
f"wmp
Go
oVTECEC               -> new line instead of replacing old line
h"wp
        -> close block
)

  -> MOTION-CMD block
     -> first write out an empty block
GoMOTION-CMDS ( )
     -> delete all write-cmd blocks
:%s/             -> begin match over whole file
^MOTION-CMDS\s(  -> beginning of block
\_[^)]\+         -> any non-closing paren (including new lines)
)\_.             -> closing block
//             -> substitue for nothing
     -> write out the motion-cmd group
        -> header
GoMOTION-CMDS (
        -> up cmd
UP   : k@l
        -> down cmd
DWN  : j@l
        -> hold cmd
HLD  : 0@l
        -> stop cmd
STOP : 0
)

  -> MACRO E
  -> escape the command that has been read from the tape
  -> We need to escape the triple escapes first, so that all
  -> the other escapes don't keep getting re-escaped
  -> Characters that should have triple escapes: *\
  -> Characters that should have double escapes: (){:
  -> Characters that should have single escapes: .[]/^$
Go            -> begin writing the macro
GoEC           -> insert an empty line at the end of the file
"cp              -> put out the command
                 -> escape the triple escape characters
I*EC              -> insert a * at the beginning of the line
:s/
\([*\\]\)           -> look for special characters
/\\\\\\\1/g         -> put two slashes in front of any matches
CR
0xxxx               -> delete the '///*' (now) at the beginning of the line
                 -> escape the double escape characters
I(EC              -> insert a paren at the beginning of the line
:s/
\([(){]\)           -> look for special characters
/\\\\\1/g           -> put two slashes in front of any matches
CR
0xxx                -> delete the '//(' (now) at the beginning of the line
                 -> escape the single escape characters
I.EC              -> insert a '.' at the beginning of the line
:s/
\([.[\]/^$]\)       -> look for special characters
/\\\1/g             -> put a slash in front of any matches
CR                -> execute the search
0xx                 -> delete the '\.' (now) at the beginning of the line
"cd$             -> yank the line into reg c
dd               -> remove the extra line we've added
"edd        -> finish writing and load macro

  -> MACRO J
  -> jump to the state containing your command
  -> or fail if it doesn't exist
Go            -> begin writing
/                -> start search
^D2s\s\+{      -> line starting with [state] {
\_[^}]\{-}       -> as few as possible characters excluding '}'
\(               -> begin a sub match of either...
\\\@<!(\*)          -> a splat wrapped in parentheses
\|                     -> or
                    -> the command wrapped in parentheses
\\\@<!(                -> opening paren without escape
D2c                  -> the contents of reg c
\(\\\\\)*)             -> a paren escaped either no times, or a multiple of two times
\)               -> end submatch
.*\s:\s\+        -> the colon surrounded by white space
                 -> NOTE that we don't include new lines here
                 -> i.e. the colon has to occur on the same line
\zs              -> start the match after the colon (so we jump right to it)
\_[^}]*          -> no closing braces
}                -> a closing brace starting a line
CR             -> enter (to execute the search)
"jdd        -> finish writing and load macro


  -> MACRO R
  -> Load part w (for write)

Go            -> begin writing
  -> read the write cmd
"wye             -> load command (temporarily) into reg w
wmp              -> advance to next command, mark place

  -> search for macro related to write-cmd
/                -> start search
^WRITE-CMDS\s(   -> only look in the write cmds
\_[^)]*          -> no closing parens
D2w            -> the matching command
.*\s:\s\+        -> the colon separating the commands
\zs              -> begin match (so we jump after the colon
\_[^)]*          -> make sure the command occurs before any closing paren
)CR            -> complete search

  -> load cmd into w
"wy$             -> yank that macro (temporarily) into w
G@w              -> go to the bottom, call temp w
"wdd             -> finally load into w

  -> load part m for motion
`p               -> return to where we left off
"mye             -> load command (temporarily) into reg m
wmp              -> advance to next command, mark place

  -> search for macro related to motion-cmd
  -> (same comments as write-cmd above)
/
^MOTION-CMDS\s(
\_[^)]*
D2m
.*\s:\s\+
\zs
\_[^)]*
)CR

  -> load the actual motion
"my$

  -> load the state
`p               -> return to place
"syE             -> load state

"rdd        -> finish writing and load macro

  -> MACRO L
  -> the main loop of the interpreter
Go            -> begin writing
0"cy$            -> load the line into c
EBl            -> go to the turing instructions
@e               -> escape the command before escape
@j               -> jump to command
@r               -> read state machine commands
EBh            -> go to the tape
@w               -> write to the tape
@m               -> execute the motion
"ldd        -> finish writing and load macro

  -> MACRO T
  -> set the inital state and call the main loop
Go            -> begin writing
OSTARTEC       -> write out the start state
0"syE            -> load the start state in s
dd               -> clean up
@l               -> run the main loop
"tdd        -> finish writing and load macro

=END
